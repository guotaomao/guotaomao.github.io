<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MGT360124</title>
  
  <subtitle>web开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mymgt360124.cn/"/>
  <updated>2019-04-11T01:37:48.636Z</updated>
  <id>http://www.mymgt360124.cn/</id>
  
  <author>
    <name>MGT360124</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue2利用v-Model实现自定义组件props双向绑定的优美方案</title>
    <link href="http://www.mymgt360124.cn/2017/10/22/vue2%E5%88%A9%E7%94%A8v-model%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6props%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E7%BE%8E%E6%96%B9%E6%A1%88/"/>
    <id>http://www.mymgt360124.cn/2017/10/22/vue2利用v-model实现组件props双向绑定的优美方案/</id>
    <published>2017-10-22T13:00:04.000Z</published>
    <updated>2019-04-11T01:37:48.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h1><pre><code class="html">&lt;template&gt;   &lt;div class=&quot;keyboard&quot;&gt;     &lt;aui-digit-keyboard      :label=&#39;label&#39;      :readonly=&quot;readonly&quot;      :disabled=&quot;disabled&quot;      :autofocus=&quot;autofocus&quot;      :placeholder=&quot;placeholder&quot;      :type=&quot;type&quot;      :name=&quot;name&quot;      :format=&quot;format&quot;      :keyboard=&#39;keyboard&#39;      :maxlength=&quot;maxlength&quot;      v-model=&quot;amount&quot;&gt;        &lt;/aui-digit-keyboard&gt;   &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    data(){      return {        amount:&#39;&#39;,        label: &quot;单价&quot;,        autofocus: false,        disabled:false,        maxlength:6,        placeholder:&quot;0.00&quot;,        readonly:false,        type: &quot;tel&quot;,        name:&quot;&quot;,        format:&quot;&quot;,        keyboard:{}      }    },    watch:{        amount(){          console.log(&quot;this.amount&quot;,this.amount)        }    },    methods: {    }  }&lt;/script&gt;</code></pre><p>关键是 v-model= ‘amount’和 watch:{amount(){ …}}</p><h1 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h1><pre><code class="html">&lt;template&gt;&lt;div  class=&quot;key-container&quot;&gt;  &lt;div class=&quot;input&quot;&gt;    &lt;label&gt;{{label}}&lt;/label&gt;    &lt;NumericInput    :label=&#39;label&#39;      :readonly=&quot;readonly&quot;      :disabled=&quot;disabled&quot;      :autofocus=&quot;autofocus&quot;      :placeholder=&quot;placeholder&quot;      :type=&quot;type&quot;      :name=&quot;name&quot;      :format=&quot;format&quot;      :keyboard=&#39;keyboard&#39;      :maxlength=&quot;maxlength&quot;      v-model=&quot;amount&quot;      /&gt;  &lt;/div&gt;   &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { NumericInput } from &quot;numeric-keyboard&quot;;export default {  name: &quot;aui-digit-keyboard&quot;,  components: {    NumericInput,  },  data() {    return {    };  },  computed:{    amount:{      get: function() {        return this.value;      },      set: function(val) {        this.$emit(&quot;input&quot;,val)      }    }  },  methods: {  },  props: {    label:{      type: String,      default: &#39;金额&#39;    },    type: {      type: String,      default: &quot;number&quot;    },    autofocus: {      type: Boolean,      default: false    },    disabled: {      type: Boolean,      default: false    },    maxlength: {      type: Number    },    name: {      type: String    },    placeholder: {      type: String    },    readonly: {      type: Boolean,      default: false    },    value: {      type: [String, Number],      default:&#39;&#39;    },    format: {      type: [String, Function]    },    keyboard: {      type: Object    }  }};&lt;/script&gt;</code></pre><p>子组件是在props属性中定义一个value属性</p><pre><code class="js">&lt;NumericInput v-model=&#39;amount&#39;/&gt;props:{    //接收一个由父组件传递过来的值    value:{        type:String,        default:&quot;&quot;    }},computed:{    amount:{        //动态计算amount的值       get:function(){           //将props中的value赋值给 amount           return this.value       },       set: function(val){           //通过$emit触发父组件,必须用input事件           this.$emit(&quot;input&quot;,val)       }    }}</code></pre><p>在计算属性computed:{}对象中属性不能是data中的也不能是props中的属性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;父组件&quot;&gt;&lt;a href=&quot;#父组件&quot; class=&quot;headerlink&quot; title=&quot;父组件&quot;&gt;&lt;/a&gt;父组件&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
   &amp;lt;div class=&amp;quot;keybo
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/categories/javascript/"/>
    
      <category term="vue" scheme="http://www.mymgt360124.cn/categories/javascript/vue/"/>
    
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/tags/javascript/"/>
    
      <category term="vue" scheme="http://www.mymgt360124.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Webpack概念</title>
    <link href="http://www.mymgt360124.cn/2017/10/10/webpack/"/>
    <id>http://www.mymgt360124.cn/2017/10/10/webpack/</id>
    <published>2017-10-10T13:00:04.000Z</published>
    <updated>2019-04-11T01:37:48.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念-本质上，webpack是一个现代JavaScript应用程序的静态模块打包器，当webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle"><a href="#概念-本质上，webpack是一个现代JavaScript应用程序的静态模块打包器，当webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle" class="headerlink" title="概念: 本质上，webpack是一个现代JavaScript应用程序的静态模块打包器，当webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle"></a>概念: 本质上，webpack是一个现代JavaScript应用程序的静态模块打包器，当webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle</h1><h1 id="四个核心的概念："><a href="#四个核心的概念：" class="headerlink" title="四个核心的概念："></a>四个核心的概念：</h1><ol><li>入口(entry)</li><li>输出(output)</li><li>(loader)</li><li>插件(plugins)</li></ol><h2 id="入口entry"><a href="#入口entry" class="headerlink" title="入口entry"></a>入口entry</h2><p>入口起点 entry point 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，进入入口起点后，webpack会找出那些模块和库是入口起点(直接和间接)依赖的.<br>每个依赖项随即被处理，最后输出到称之为bundles的文件中<br>可以通过wepack配置中配置entry属性，来指定一个入口起点(或者多个入口起点)。<br>这是一个entry配置的最简单的例子：<br>webpack.config.js</p><pre><code class="js">module.exports = {    entry: &#39;./path/to/my/entry/file.js&#39;};</code></pre><h2 id="出口output"><a href="#出口output" class="headerlink" title="出口output"></a>出口output</h2><p>output属性告诉webpack在哪里输出它所创建的bundles,以及如何命名这些文件。你可以通过在配置中指定一个output字段，来配置这些处理过程：<br>webpack.config.js</p><pre><code class="js">const path = require(&quot;path&quot;);module.exports = {    entry: &#39;./path/to/entry/file.js&#39;,    output: {        path: path.resolve(__dirname, &quot;dist&quot;),        filename: &#39;my-first-webpack.bundle.js&#39;    }};</code></pre><p>上面的例子，是通过output.filename 和 output.path属性，来告诉webpack bundle的名称，以及我们想要生成(emit)到哪里。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader让webpack能够去处理那些非JavaScript文件(webpack 自身只理解JavaScript)，loader可以将所有类型文件转换为webpack能够处理的有效模块，然后你就可以利用webpack的打包能力，对他们进行处理。<br>本质上，webpack loader将所有类型文件，转换为应用程序的依赖图(和最终的bundle)可以直接引用的模块。<br>loader能够import导入任何类型的模块(例如.css文件)，这是webpack特有的功能，其他打包程序或任务执行器的可能并不支持，我们认为这种语言扩展是有必要的，因为这可以是开发人员创建出更准确的依赖关系图。<br>在更高层面上，在webpack的配置中loader有两个目标：</p><ol><li>test属性，用于标识出应该被对应的loader进行转换的某个或某些文件</li><li>use属性，表示进行转换时，应该使用哪个loader。<br>webpack.config.js<pre><code class="js">const path = require(&quot;path&quot;);const config = { entry: &quot;./path/to/my/entry/file.js&quot;, output: {     path: path.resolve(__dirname,&quot;dist&quot;),     filename: &#39;my-first-webpack.bundle.js&#39; }, module: {     rules :[         {test: /\.txt$/, use: &#39;raw-loader&#39;}     ] }}</code></pre>以上配置中，对一个单独的module对象定义了rules属性，里面包含两个属性：test和use。这告诉webpack编译器compiler一下信息：<br>‘嘿，webpack 编译器，当你碰到在require()/import语句中被解析为.txt的路径时,在你对它打包之前，先使用raw-loader转换一下’ 注意的是，在webpack配置中定义loader时，要定义在module.rules中，而不是rules. 然而，在定义错误时，webpack会给出严重的警告。为了使你受益于此，如果没有按照正确的方式去做，webpack会给出严重的警告。<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2>loader被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量，插件接口功能极其强大，可以用来处理各种各样的任务。<br>想要使用一个插件，你只需要require()它，然后把它添加到plugins数组中，多数插件可以通过选项option自定义，你也可以在配置文件中应为不同目的而多次使用同一个插件，这时需要通过使用new 操作符来创建它的一个实例<br>webpack.config.js<pre><code class="js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);//通过npm 安装const webpack = require(&quot;webpack&quot;); //用于访问内置插件const path = require(&quot;path&quot;);const config = { entry: &#39;./path/to/entry/file.js&#39;, output: {     path: path.resolve(__dirname,&#39;dist&#39;),     filename: &#39;my-first-webpack.bundle.js&#39; }, module: {     rules :[         {test: /\.txt$/,use: &#39;raw-loader&#39;}     ] }, plugins: [     new webpack.optimize.UglifyJsPlugin(),     new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;}) ]};module.export = config;</code></pre></li></ol><h1 id="入口起点-entry-points"><a href="#入口起点-entry-points" class="headerlink" title="入口起点 entry points"></a>入口起点 entry points</h1><p>在webpack配置中有多种方式定义 entry 属性 </p><h2 id="单个入口语法-用法-entry-string-Array"><a href="#单个入口语法-用法-entry-string-Array" class="headerlink" title="单个入口语法 用法:entry: string| Array"></a>单个入口语法 用法:entry: string| Array<string></string></h2><p>webpack.config.js</p><pre><code class="js">const config = {    entry: &#39;./path/to/my/entry/file.js&#39;};module.exports = config;</code></pre><p>entry 属性的单个入口语法，是下面的简写</p><pre><code class="js">const config  = {    entry: {        main: &#39;./path/to/my/entry/file.js&#39;    }};</code></pre><p>向entry 属性传入[文件路径file path数组]将创建多个主入口。当你想要多个依赖文件一起注入，并且将他们的依赖导向到一个chunk时，传入数组的范式就很有用</p><h2 id="对象语法-用法-entry-entryChunkName-string-string-Array"><a href="#对象语法-用法-entry-entryChunkName-string-string-Array" class="headerlink" title="对象语法 用法: entry:{[entryChunkName: string]: string| Array}"></a>对象语法 用法: entry:{[entryChunkName: string]: string| Array<string>}</string></h2><p>webpack.config.js</p><pre><code class="js">const config = {    entry: {        app: &#39;./src/app.js&#39;,        vendors: &#39;./src/vendors.js&#39;    }};</code></pre><p>对象语法会比较繁琐，然而这时应用程序中定义入口的最可扩展的方式</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><p>分离应用程序app 和第三方库(vendor) 入口<br>webpack.config.js</p><pre><code class="js">const config = {    entry: {        app: &#39;./src/app.js&#39;,        vendors: &#39;./src/vendors.js&#39;    }}</code></pre><p>从表面上看，这告诉我们webpack 从app.js 和vendors.js开始创建依赖图 ，这些依赖图是彼此完全分离，相互独立的(每个bundle中都有一个webpack引导bootstrap), 这种方法比较常见，只有一个入口起点(不包括vendor)的单页应用程序(single page application)中。</p><h2 id="多页应用程序"><a href="#多页应用程序" class="headerlink" title="多页应用程序"></a>多页应用程序</h2><p>webpack.config.js</p><pre><code class="js">const config = {    entry: {        pageOne: &#39;./src/pageOne/index.js&#39;,        pageTwo: &#39;./src/pageTwo/index.js&#39;,        pageThree: &#39;./src/pageThree/index.js&#39;    }}</code></pre><p>我们告诉webpack需要3个独立分离的依赖图</p><h1 id="输出-output"><a href="#输出-output" class="headerlink" title="输出 output"></a>输出 output</h1><p>配置output 选项可以控制webpack如何向硬盘写入编译文件，注意，即使可以存在多个入口起点，但只指定一个输出配置。</p><h2 id="用法-usage"><a href="#用法-usage" class="headerlink" title="用法 usage"></a>用法 usage</h2><p>在webpack中配置output属性的最低要求是，将它的值设置为一个对象，包括两点：</p><ol><li>filename 用于输出文件的文件名。</li><li>目标输出目录path的绝对路径。<pre><code class="js">webpack.config.js = { output: {     filename: &#39;bundle.js&#39;,     path: &#39;./home/proj/public/assets&#39; }};module.exports = config;</code></pre>此配置将一个单独的bundle.js文件输出到/home/proj/public/assets目录中。</li></ol><h2 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h2><p>如果配置创建了多个单独的chunk,则应该使用占位符来确保每个文件具有唯一的名称</p><pre><code class="js">{    entry: {        app: &#39;./src/app.js&#39;,        search: &#39;./src/search.js&#39;    },    output: {        filename: &#39;[name].js&#39;,        path: __dirname + &#39;/dist&#39;    }}// 写入到硬盘中: ./dist/app.js, ./dist/search.js</code></pre><h2 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h2><p>config.js</p><pre><code class="js">output :{    path: &#39;./home/proj/cdn/assets/[hash]&#39;,    publicPath: &#39;http://cdn,example.com/assets/[hash]/&#39;}</code></pre><h1 id="loader-1"><a href="#loader-1" class="headerlink" title="loader"></a>loader</h1><p>loader用于对模块的源码进行转换，loader可以使你在import或’加载’模块时预处理文件，因此loader类似于其他构件工具中 ‘任务task’ 并提供了处理前端构建步骤的强大方法，loader可以将文件从不同的语言(例如TypeScript)转换JavaScript,或者内联图像转换为data URL。loader甚至允许你直接在JavaScript模块中 import css文件。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用loader告诉webpack加载css文件，或者TypeScript转换为JavaScript,为此首先安装对应的loader:</p><pre><code class="js">npm install --save-dev css-loadernpm install --save-dev ts-loader</code></pre><p>然后指示webpack对每个.css使用css-loader,以及对所有.ts文件使用ts-loader：<br>webpack.config.js</p><pre><code class="js">module.exports = {    module: {        rules:[            {test:/\.css$/, use: &#39;css-loader&#39;},            {test:/\.ts$/,use: &#39;ts-loader&#39;}        ]    }}</code></pre><h2 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h2><p>在应用程序中，有三种方式使用loader：</p><ol><li>配置(推荐)，在webpack.config.js文件中指定laoder</li><li>内联： 在每个import语句中显式指定loader</li><li>cli 在shell命令中指定他们</li></ol><h2 id="配置-configuration"><a href="#配置-configuration" class="headerlink" title="配置[configuration]"></a>配置[configuration]</h2><p>module.rules 允许你在webpack配置中指定多个loader，这是展示loader的一种简明方式，并且有助于使代码变得简洁，同时让你对各个loader有个全局概览:</p><pre><code class="js">module :{    rules:[        {test:/\.css$/,        use: [            {loader: &#39;style-loader&#39;},            {                loader: &#39;css-loader&#39;,                options: {                    modules : true                }            }        ]        }    ]}</code></pre><h2 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h2><p>可以在 import 语句或任何等效于import的方式中指定loader。使用！将资源中的loader分开。分开的每个部分都相对于当前目录解析。</p><pre><code class="js">import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;;</code></pre><h2 id="cli-通过处理使用loader"><a href="#cli-通过处理使用loader" class="headerlink" title="cli 通过处理使用loader"></a>cli 通过处理使用loader</h2><pre><code class="js">webpack --module-bind jade-loader --module-bind &#39;css=style-loader!css-loader&#39;</code></pre><p>这会对.jade文件使用jade-laoder，对.css文件使用style-loader和css-loader</p><h2 id="loader特性"><a href="#loader特性" class="headerlink" title="loader特性"></a>loader特性</h2><ol><li>loader支持链式传递，能够对资源使用流水线pipeline，一组链式的loader将按照相反的顺序执行，loader链式中的第一个loader返回值给下一个loader。在最后一个loader, 返回webpack所预期的JavaScript</li><li>loader可以是同步的，也可以是一步的</li><li>loader 运行在node.js 中，并且能够执行任何可能的操作</li><li>loader 也能够使用options 对象进行配置</li><li>除了使用package.json常见的main属性，还可以将普通的npm 模块导出为loader, 做法是在 package.json 里定义一个loader字段<h2 id="解析loader"><a href="#解析loader" class="headerlink" title="解析loader"></a>解析loader</h2>loader遵循标准的模块解析，多数情况下，loader将从模块路径(通常将模块路径认为是npm install, node_modules)解析。</li></ol><h1 id="插件Plugins"><a href="#插件Plugins" class="headerlink" title="插件Plugins"></a>插件Plugins</h1><p>插件是webpack的支柱功能，webpack自身也是构建于，在webpack配置中用到的相同的插件系统之上。插件目的在于解决loader无法实现的其他事。</p><h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>webpack插件是一个具有apply属性的JavaScript对象。apply属性会被webpack compiler调用，并且compiler对象可在整个编译生命周期访问。<br>ConsoleLogOnBuildWebpackPlugin.js</p><pre><code class="js">function ConsoleLogOnBuildWebpackPlugin () {}ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) {    compiler.plugin(&#39;run&#39;,function(compiler,callback){        console.log(&quot;webpack 构建过程开始！！！&quot;);        callback();    });};</code></pre><h2 id="用法-由于插件可以携带参数、选项。在webpack配置中，向plugins属性传入new-实例。"><a href="#用法-由于插件可以携带参数、选项。在webpack配置中，向plugins属性传入new-实例。" class="headerlink" title="用法 由于插件可以携带参数、选项。在webpack配置中，向plugins属性传入new 实例。"></a>用法 由于插件可以携带参数、选项。在webpack配置中，向plugins属性传入new 实例。</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>webpack.config.js</p><pre><code class="js">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); //通过npm安装const webpack = require(&quot;webpack&quot;); //访问内置的插件const path = require(&quot;path&quot;);const config = {    entry: &quot;./path/to/my/entry/file.js&quot;,    output: {        filename: &#39;my-first-webpack.bundle.js&#39;,        path: path.resolve(__dirname,&quot;dist&quot;)    },    module:{        loaders: [            {                test: /\.(js|jsx)$/,                use: &#39;babel-loader&#39;            }        ]    },    plugins: [        new webpack.optimize.UglifyJsPlugin(),        new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})    ]};module.exports = config;</code></pre><h2 id="node-api"><a href="#node-api" class="headerlink" title="node api"></a>node api</h2><p>即使使用node api ,用户也应该在配置中传入plugins属性，compiler.apply并不是推荐的使用方式。<br>some-node-script.js</p><pre><code class="js">const webpack = require(&quot;webpack&quot;);const configuration = require(&quot;./webpack.config.js&quot;);let compiler = webpack(configuration);compiler.apply(new webpack.ProgressPlugin());compiler.run(function (err,stats) {    //...});</code></pre><h1 id="配置configuration"><a href="#配置configuration" class="headerlink" title="配置configuration"></a>配置configuration</h1><p>很少有webpack配置看起来很完全相同，这是因为webpack的配置文件，是导出一个对象的JavaScript文件，此对象由webpack根据对象定义的属性进行解析。<br>因为webpack配置是标准的node.js commonJS模块，你可以做到以下事情：</p><ol><li>通过require(…) 导入其他文件</li><li>通过require(…) 使用npm的工具函数</li><li>使用JavaScript控制流表达式，例如 ?:操作符</li><li>对常用值使用常量或变量</li><li>编写并执行函数来生成部分配置</li></ol><p>但是应该避免以下做法:</p><ol><li>在使用webpack命令行接口cli(应该编写自己的命令行cli,或者使用 –env)时，访问命令行接口cli参数</li><li>导出不确定的值(调用webpack两次应该产生同样的输出文件)</li><li>编写很长的配置(应该讲配置拆分为多个文件)</li></ol><h2 id="最简单的配置"><a href="#最简单的配置" class="headerlink" title="最简单的配置"></a>最简单的配置</h2><p>webpack.config.js</p><pre><code class="js">var path = require(&#39;path&#39;);module.exports = {    entry: &#39;./foo.js&#39;,    output: {        path: path.resolve(_dirname,&#39;dist&#39;),        filename: &#39;foo.bundle.js&#39;    }};</code></pre><h1 id="模块Modules"><a href="#模块Modules" class="headerlink" title="模块Modules"></a>模块Modules</h1><p>在模块化编程中，开发者将程序分解成离散功能块，并称之为模块。<br>每个模块具有比完整程序更小的接触面，是的校验，调试，测试轻而易举。精心编写的模块提供了可靠的抽象和封装界限，是的应用程序中每个模块都具有条理清晰的设计和明确的目的。</p><h2 id="什么是webpack模块"><a href="#什么是webpack模块" class="headerlink" title="什么是webpack模块"></a>什么是webpack模块</h2><p>对比node.js模块，webpack模块能够以各种方式表达他们的依赖关系，</p><ol><li>ES5 import语句</li><li>CommonJS require()语句</li><li>AMD define和require()语句</li><li>css/sass/less文件中的@import语句</li><li>样式url() 或者HTML中的图片链接image url <h2 id="支持的模块类型"><a href="#支持的模块类型" class="headerlink" title="支持的模块类型"></a>支持的模块类型</h2>webpack 通过loader可以支持各种语言和预处理器编写模块，loader描述了webpack如何处理非JavaScript模块，并且在bundle中引入这些依赖，webpack社区已经为各种流行语言和语言吹器构建了loader</li><li>coffeeScript</li><li>TypeScript</li><li>ESNext</li><li>sass</li><li>less</li><li>stylus<h1 id="模块解析-module-resolution"><a href="#模块解析-module-resolution" class="headerlink" title="模块解析 module resolution"></a>模块解析 module resolution</h1>resolver 是一个库 ，用于帮助找到模块的绝对路径，一个模块可以作为另一个模块的依赖模块，然后被后者引用。<pre><code class="js">import foo from &#39;path/to/module&#39;// 或者require(&#39;path/to/module&#39;)</code></pre>所依赖的模块可以使来自应用程序代码或者第三方的库,resolver帮助webpack找到bundle中需要引入的模块代码，这些代码在包含在每个require/import语句中，当打包模块时，webpack使用enhanced-resolve来解析文件的路径<h2 id="webpack-中解析规则"><a href="#webpack-中解析规则" class="headerlink" title="webpack 中解析规则"></a>webpack 中解析规则</h2>使用enhanced-resolve，webpack能够解析三种文件路径： 绝对路径，相对路径，模块路径</li><li><p>绝对路径</p><pre><code class="js">import &#39;/home/me/file&#39;;import &#39;C:\\Users\\me\\file&#39;;</code></pre><p>由于我们已经有了文件的绝对路径，因此不需要在进一步解析</p></li><li><p>相对路径</p><pre><code class="js">import &#39;../src/file1&#39;;import &#39;./file2&#39;</code></pre><p>在这种情况下，使用import或者require的资源文件resource file所在的目录被认为是上下文目录context directory，在import /require中给定的相对路径，会添加次上下文路径context path,以产生模块的绝对路径.</p><h1 id="依赖图-dependency-graph"><a href="#依赖图-dependency-graph" class="headerlink" title="依赖图 dependency graph"></a>依赖图 dependency graph</h1><p>任何时候，一个文件依赖于另一个文件，webpack就把此视为文件之间的依赖关系，这使得webpack可以接受非代码资源例如图像或者web字体，并且可以把他们作为依赖提供给你的应用程序。<br>webpack 从命令行或者配置文件中定义的一个模块列表开始，处理你的应用程序，从这些入口七点开始，webpack递归的构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的bundle，通常只有一个。</p><h1 id="构建目标-Targets"><a href="#构建目标-Targets" class="headerlink" title="构建目标 Targets"></a>构建目标 Targets</h1><h2 id="要设置target属性，只需要在你的webpack配置中设置target的值"><a href="#要设置target属性，只需要在你的webpack配置中设置target的值" class="headerlink" title="要设置target属性，只需要在你的webpack配置中设置target的值"></a>要设置target属性，只需要在你的webpack配置中设置target的值</h2><p>webpack.config.js</p><pre><code class="js">module.exports = { target: &#39;node&#39;};</code></pre><p>更多说明，请参考<a href="https://doc.webpack-china.org/" target="_blank" rel="noopener">webpack官网</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念-本质上，webpack是一个现代JavaScript应用程序的静态模块打包器，当webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle&quot;&gt;&lt;a href=&quot;#概念-本质上，w
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/categories/javascript/"/>
    
      <category term="webpack" scheme="http://www.mymgt360124.cn/categories/javascript/webpack/"/>
    
      <category term="vue.js" scheme="http://www.mymgt360124.cn/categories/javascript/webpack/vue-js/"/>
    
    
      <category term="vue.js" scheme="http://www.mymgt360124.cn/tags/vue-js/"/>
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/tags/javascript/"/>
    
      <category term="webpack" scheme="http://www.mymgt360124.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Js面向对象的类型检测</title>
    <link href="http://www.mymgt360124.cn/2017/10/08/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    <id>http://www.mymgt360124.cn/2017/10/08/js面向对象的类型检测/</id>
    <published>2017-10-08T13:00:04.000Z</published>
    <updated>2019-04-11T01:37:48.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h1><pre><code class="js">// 接收 任意数量的参数并将其转换为数组的函数function makeAarry () {    // 临时的数组容器    var arr = [];    for (var i =0;i&lt; arguments.length;i++) {        arr.push(arguments[i]);    }    return arr;}// 用这一特性可以显示错误信息和默认信息function displayerror (msg) {    if (typeof msg == &#39;undefined&#39;) {        msg = &quot;An error occurred&quot;;    }    alert(msg);}</code></pre><pre><code class="js">// js数据类型检测function istypeof (a) {    if(typeof a === &#39;number&#39;) {        return a+ &quot;is number&quot;;    }    if ( typeof a === &quot;string&quot;) {        return a + &quot;is string&quot;    }      if ( typeof a === &quot;boolean&quot;) {        return a+ &quot;is boolean&quot;    }    if( typeof a === &quot;function&quot;) {        return a + &quot;is function&quot;;    }    if( a.constructor === Array) {        return a + &quot;is Array&quot;;    }    if (a.constructor === Object) {        return a + &quot;is Object&quot;;    }}</code></pre><pre><code class="js">var arr = [], obj = {};// 因为typeof arr === &quot;object&quot;;typeof obj === &quot;object&quot;;// 所以用constructor 来检测</code></pre><h1 id="属性标签和属性检测"><a href="#属性标签和属性检测" class="headerlink" title="属性标签和属性检测"></a>属性标签和属性检测</h1><pre><code class="js">// 属性检测Object.definProperty()自定义的方法Object.defineProperty(car, &quot;price&quot;,{enumerable: false,value :1000 });为car 对象设置price 属性，car.price = 1000;// 第一个参数是要添加属性的对象// 第二个参数设计要添加的属性// 第三个参数是一个对象(设置一些标签)// enumerable: false; 表示不可枚举，即不能沿原型链向上被 for in 循环到// value :1000 , 即price 属性的值为1000;</code></pre><h2 id="一如果用的字面量和new-创建的对象属性，默认他的enumerable-和-writable-和-configurable-都是为true-的，既可以写，可以删除，可以配置；"><a href="#一如果用的字面量和new-创建的对象属性，默认他的enumerable-和-writable-和-configurable-都是为true-的，既可以写，可以删除，可以配置；" class="headerlink" title="一如果用的字面量和new 创建的对象属性，默认他的enumerable 和 writable 和 configurable 都是为true 的，既可以写，可以删除，可以配置；"></a>一如果用的字面量和new 创建的对象属性，默认他的enumerable 和 writable 和 configurable 都是为true 的，既可以写，可以删除，可以配置；</h2><h2 id="二如果用Object-defineProperty-不做声明的话，默认创建的对象额属性他的：enumerable和writable和configurable-标签都是为false-configurable-true-则delete-可以删除的"><a href="#二如果用Object-defineProperty-不做声明的话，默认创建的对象额属性他的：enumerable和writable和configurable-标签都是为false-configurable-true-则delete-可以删除的" class="headerlink" title="二如果用Object.defineProperty();不做声明的话，默认创建的对象额属性他的：enumerable和writable和configurable 标签都是为false; configurable: true; 则delete 可以删除的;"></a>二如果用Object.defineProperty();不做声明的话，默认创建的对象额属性他的：enumerable和writable和configurable 标签都是为false; configurable: true; 则delete 可以删除的;</h2><p>#geter和seter方法</p><pre><code class="js">function Dog () {}    Object.defineProperty(Dog.prototype,name&#39;,{        get : function () {return &quot;大黄&quot;}    }) var dog = Dog();dog.name;//大黄</code></pre><p>也可以这样编写</p><pre><code class="js">function Dog () {}    Dog.prototype = {        name : function () {            return &quot;大黄&quot;;        }    } var dog = new Dog(); dog.name();  //大黄</code></pre><p>属性标签value , writable ,enumerable, configurable ; Object.getOwnPropertyDescriptor()获取对象属性标签的状态</p><pre><code class="js">Object.getOwnPropertyDescriptor({name: &quot;MGT360124&quot;}, &#39;name&#39;);//Object{value: true, writable: true,enumable: true,configurable: true}</code></pre><p>writable:true则属性的值表示可修改<br>enumerable:true表示属性的值可遍历，用for in 遍历则会遍历对象原型的值，可以用Obj.hasOwnProperty(key)过滤;<br>configurable ：true表示属性的值可删除</p><h1 id="Object-defineProperties-为对象添加定义多个属性和属性标签"><a href="#Object-defineProperties-为对象添加定义多个属性和属性标签" class="headerlink" title="Object.defineProperties()为对象添加定义多个属性和属性标签"></a>Object.defineProperties()为对象添加定义多个属性和属性标签</h1><pre><code class="js">var person = {}Object.defineProperties(person,{name:{value:&quot;MGT360124&quot;,writable: false},age: {value:18,enumerable: false },city:{value: &quot;beijing&quot;,enumerable: false},getLuck: {get : function () { return Math.random(); }},setCity: {set : function (city) { this.city = city + &quot;--中国&quot;;} }});person.city;person.setCity = &quot;南昌&quot;;person.city; //南昌--中国</code></pre><h1 id="用for-in-遍历则会遍历对象原型的值，可以用Obj-hasOwnProperty-key-过滤-阻止for-in循环沿原型链向上查找"><a href="#用for-in-遍历则会遍历对象原型的值，可以用Obj-hasOwnProperty-key-过滤-阻止for-in循环沿原型链向上查找" class="headerlink" title="用for in 遍历则会遍历对象原型的值，可以用Obj.hasOwnProperty(key)过滤;阻止for in循环沿原型链向上查找"></a>用for in 遍历则会遍历对象原型的值，可以用Obj.hasOwnProperty(key)过滤;阻止for in循环沿原型链向上查找</h1><pre><code class="js">function Dog() {    name = &#39;大黄&#39;;}Dog.prototype = {    color : &quot;yellow&quot;,    getColor : function () {        return this.name;    }}var dog = new Dog();dog.name = &quot;二哈&quot;for(var key in dog){    if(dog.hasOwnProperty(key) ) {        console.log(dog[key]); // &quot;二哈&quot;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型检测&quot;&gt;&lt;a href=&quot;#数据类型检测&quot; class=&quot;headerlink&quot; title=&quot;数据类型检测&quot;&gt;&lt;/a&gt;数据类型检测&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// 接收 任意数量的参数并将其转换为数组的函数
function m
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/categories/javascript/"/>
    
    
      <category term="vue.js" scheme="http://www.mymgt360124.cn/tags/vue-js/"/>
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>用Js获取网页元素的位置</title>
    <link href="http://www.mymgt360124.cn/2017/10/06/%E7%94%A8js%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.mymgt360124.cn/2017/10/06/用js获取网页元素的位置/</id>
    <published>2017-10-06T13:00:04.000Z</published>
    <updated>2019-04-11T01:37:48.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网页的大小和浏览器窗口的大小"><a href="#网页的大小和浏览器窗口的大小" class="headerlink" title="网页的大小和浏览器窗口的大小"></a>网页的大小和浏览器窗口的大小</h1><p>一张网页的全部面积，就是它的大小，通常情况下，网页的大小由内容和css样式表决定。<br>浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport(视口)。<br>很显然，如果网页的内容能够在浏览器窗口中全部显示（也就是不出现滚动条），那么网页的大小和浏览器窗口的大小是相等的。如果不能全部显示，则滚动浏览器窗口，可以显示出网页的各个部分。 </p><h1 id="获取网页的大小"><a href="#获取网页的大小" class="headerlink" title="获取网页的大小"></a>获取网页的大小</h1><p>网页上的每个元素，都有clientHeight和clientWidth属性，这两个属性指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。<br><img src="https://files.jb51.net/file_images/article/201312/201312091712081.gif?2013119171231" alt=""><br>因此，document元素的clientHeight和clientWidth属性，就代表了网页的大小</p><pre><code>function getViewport(){    if(document.compatMode  ==  &#39;BackCompat&#39;){        return {            wdith: document.body.clientWidth,            height: document.body.clientHeight        }    }else{        return {            width: document.documentElement.clientWdith,            height: document.documentElement.clientHeight        }    }}</code></pre><p>getViewport函数就可以返回浏览器窗口的高度和宽度，使用的时候，有三个地方需要注意：<br>1, 这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。<br>2, 大多数情况下，都是document.documentElement.clientWidth返回正确的值，但是在IE6中document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。<br>3, clientWidth和clientHeight都是只读属性。不能对他们赋值</p><h1 id="获取网页大小的另一种方法"><a href="#获取网页大小的另一种方法" class="headerlink" title="获取网页大小的另一种方法"></a>获取网页大小的另一种方法</h1><p>网页上的每个元素还有scrollHeight和scrollWidth属性，，指包含滚动条在内的该元素的视觉面积，那么document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。</p><pre><code>  function getPagearea (){      if (document.compatMode == &#39;BackCompat&#39;){          return {              width: document.body.scrollWidth,              height: document.body.scrollHeight          }      }else {          return {              width: document.documentElement.scrollWidth,              height: document.documentElement.scrollHeight          }      }  }</code></pre><p>   这个函数有个问题，如果网页内容能够在浏览器中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth是相等的。 但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对getPagearea()函数进行改写。</p><pre><code>function getPagearea () {    if(document.compatMode == &#39;BackCompat&#39;){        return {            width: Math.max(document.body.scrollWidth,document.body.clientWidth),            height: Math.max(document.body.scrollHeight,document.body.clientHeight)        }    }else{        return {            width : Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth),            height: Math.max(document.documentElement.scrollHeight,            document.documentElement.clientWidth)        }    }}</code></pre><h1 id="获取网页元素的绝对位置"><a href="#获取网页元素的绝对位置" class="headerlink" title="获取网页元素的绝对位置"></a>获取网页元素的绝对位置</h1><p>网页元素的绝对位置，指该元素的左上角相对于整个网页左上角的坐标，这个坐标要通过计算才能得到。<br>首先，每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器(offsetParent对象)左上角的距离，所以只需将这个值进行累加，就可以得到该元素的绝对坐标。<br><img src="https://files.jb51.net/file_images/article/201312/201312091714103.gif?2013119171424" alt=""><br>下面两个函数可用来获取绝对位置的横纵坐标</p><pre><code>  function getElementLeft (element) {         var actualLeft = element.offsetLeft;         var current = element.offsetParent;         while (current ! == null) {             actualLeft + = current.offsetLeft;             current = current.offsetParent;         }         return actualLeft;  }   function getElementTop (element) {       var actualTop = element.offsetTop;       var current = element.offsetParent;       while (current !== null ) {           actualTop += current.offsetTop;           current = current.offsetParent;       }       return actualTop;   }</code></pre><p>  由于在表格和iframe中，offsetParent对象未必等于父容器，所以上面的函数对于表格和iframe中的元素不适用。 </p><h1 id="获取网页元素的相对位置"><a href="#获取网页元素的相对位置" class="headerlink" title="获取网页元素的相对位置"></a>获取网页元素的相对位置</h1><p>  网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标</p><p>  有了绝对位置以后，获取相对位置就很容易了。只要将绝对坐标减去页面的滚动条滚动的距离就可以了，滚动条滚动的垂直距离，是document对象的scrollTop属性，滚动条滚动的水平距离是document对象的scrollLeft属性。<br>  <img src="https://files.jb51.net/file_images/article/201312/201312091713182.gif?2013119171336" alt=""></p><pre><code> function getElementViewLeft (element) {     var actualLeft = element.offsetLeft;     var current = element.offsetParent;     while (current ! == null) {         actualLeft += current.offsetLeft;         current  = current.offsetParent;     }     if (document.compatMode == &#39;BackCompat&#39;) {         var elementScrollLeft = document.body.scrollLeft;     }else {         var elementScrollLeft = document.documentElement.scrollLeft;     }     return actualLeft - elementScrollLeft; }     function getElementViewTop (element) {         var actualTop = element.offsetTop         var current = element.offsetParent         while (current ! == null) {             actualTop += current.offsetTop;             current = current.offsetParent         }         if (document.compatMode == &#39;BackCompat&#39;) {             var elementScrollTop = document.body.scrollTop;         }else {             var elementScrollTop = document.documentElement.scrollTop         }         return  actualTop - elementScrollTop;     }</code></pre><p>scrollTop和scrollLeft属性是可以赋值的，并且会立即自动滚动网页到相应的位置。因此可以利用他们改变网页元素的相对位置，另外，element.scrollIntoView()方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。</p><h1 id="获取元素位置的快速方法"><a href="#获取元素位置的快速方法" class="headerlink" title="获取元素位置的快速方法"></a>获取元素位置的快速方法</h1><p>除了上面的函数以外，还有一种快速方法，可以立刻获得网页元素的位置<br>那就是使用getBoundingClientRect()方法，它返回一个对象，其中包含了left ,right, top, bottom 四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口viewport左上角的距离。<br>所以，网页元素的相对位置就是</p><pre><code>var X = this.getBoundingClientRect().left;var Y = this.getBoundingClientRect().top;</code></pre><p>再加上滚动距离，就可以得到绝对位置</p><pre><code>var X = this.getBoundingClientRect().left + document.documentElement.scrollLeft;var Y = this.getBoundingClientRect().top + document.documentElement.scrollTop;</code></pre><p>1, clientWidth/clientHeight<br>2, scrollWidth/scrollHeight 和 scrollLeft/scrollTop<br>3, offsetWidth/offsetHeight 和 offsetLeft/offsetTop<br>4, this.getBoundingClientRect()对象的left,right,top,bottom四个属性，分别对应该元素的左上角和右下角相对于浏览器视口左上角的距离。<br>目前，IE、Firefox 3.0+、Opera 9.5+都支持该方法，而Firefox 2.x、Safari、Chrome、Konqueror不支持。<a href="http://www.jb51.net/article/44282.htm" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网页的大小和浏览器窗口的大小&quot;&gt;&lt;a href=&quot;#网页的大小和浏览器窗口的大小&quot; class=&quot;headerlink&quot; title=&quot;网页的大小和浏览器窗口的大小&quot;&gt;&lt;/a&gt;网页的大小和浏览器窗口的大小&lt;/h1&gt;&lt;p&gt;一张网页的全部面积，就是它的大小，通常情况下
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://www.mymgt360124.cn/tags/javascript/"/>
    
      <category term="css3" scheme="http://www.mymgt360124.cn/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Linux操作系统基础知识</title>
    <link href="http://www.mymgt360124.cn/2017/10/05/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.mymgt360124.cn/2017/10/05/Linux操作系统的基础知识/</id>
    <published>2017-10-05T13:00:04.000Z</published>
    <updated>2019-04-11T01:37:48.636Z</updated>
    
    <content type="html"><![CDATA[<p>计算机操作系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机操作系统&lt;/p&gt;

      
    
    </summary>
    
      <category term="计算机" scheme="http://www.mymgt360124.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="linux操作系统" scheme="http://www.mymgt360124.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://www.mymgt360124.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="linux操作系统" scheme="http://www.mymgt360124.cn/tags/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://www.mymgt360124.cn/2017/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.mymgt360124.cn/2017/10/05/计算机网络基础知识/</id>
    <published>2017-10-05T13:00:04.000Z</published>
    <updated>2019-04-11T01:37:48.636Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络</p><h2 id="1-客户端和服务端的问候礼"><a href="#1-客户端和服务端的问候礼" class="headerlink" title="1. 客户端和服务端的问候礼"></a>1. 客户端和服务端的问候礼</h2><p>用自己的话去概括一个理论或者概念，然后试着将自己的话讲述给别人听，看别人是否理解这种概念。<br>一是概括理论，二是讲理论或者方法的应用场景，三是讲这个理论的优点或者缺点。</p><h2 id="2-mac地址是48位二进制数表示的，通常用12个十六进制数表示。"><a href="#2-mac地址是48位二进制数表示的，通常用12个十六进制数表示。" class="headerlink" title="2. mac地址是48位二进制数表示的，通常用12个十六进制数表示。"></a>2. mac地址是48位二进制数表示的，通常用12个十六进制数表示。</h2><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。<br><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052905.jpg" alt="mac地址"></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。<br><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052906.png" alt="mac地址"><br>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p>mac地址是将所有的数据包发送给统一子网络下的所有计算机，这个过程首先需要ip地址来确定是哪一个子网络。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络&lt;/p&gt;
&lt;h2 id=&quot;1-客户端和服务端的问候礼&quot;&gt;&lt;a href=&quot;#1-客户端和服务端的问候礼&quot; class=&quot;headerlink&quot; title=&quot;1. 客户端和服务端的问候礼&quot;&gt;&lt;/a&gt;1. 客户端和服务端的问候礼&lt;/h2&gt;&lt;p&gt;用自己的话去概括一个理
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.mymgt360124.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="网络" scheme="http://www.mymgt360124.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机" scheme="http://www.mymgt360124.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="网络" scheme="http://www.mymgt360124.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成基础知识</title>
    <link href="http://www.mymgt360124.cn/2017/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://www.mymgt360124.cn/2017/10/05/计算机组成原理/</id>
    <published>2017-10-05T13:00:04.000Z</published>
    <updated>2019-04-11T02:12:24.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><ul><li>存储器(内存):<blockquote><p>用于存储，实现记忆功能的部件用来存放计算程序及参与运算的各种数据</p></blockquote></li><li>运算器(cpu):<blockquote><p>负责数据的算术运算和逻辑运算即数据的加工处理</p></blockquote></li><li>控制器:<blockquote><p>负责对程序规定的控制信息进行分析,控制并协调输入,输出操作或内存访问</p></blockquote></li><li>输入设备:<blockquote><p>实现计算程序和原始数据的输入</p></blockquote></li><li>输出设备:<blockquote><p>实现计算结果输出</p></blockquote></li></ul><p><img src="/images/5.jpg" alt="计算机组成原理"></p><p><img src="/images/2.jpg" alt="计算机组成原理"></p><h2 id="计算机体系结构图"><a href="#计算机体系结构图" class="headerlink" title="计算机体系结构图"></a>计算机体系结构图</h2><p><img src="/images/3.png" alt="计算机系统的体系结构图"></p><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p><img src="/images/4.jpg" alt="存储器图"></p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>定义:计算机存储是存放数据和程序的设备</p><ul><li><p>分类:</p><blockquote><p>主存储器:　　也称内存,存储直接与CPU交换信息,由半导体存储器组成</p></blockquote><blockquote><p>辅助存储器:　　也称外存,存放当前不立即使用的信息,它与主存储器批量交换信息,由磁带机,磁带盘及光盘组成</p></blockquote></li></ul><h2 id="1-异步I-O流和同步I-O流"><a href="#1-异步I-O流和同步I-O流" class="headerlink" title="1. 异步I/O流和同步I/O流"></a>1. 异步I/O流和同步I/O流</h2><h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h2><h2 id="3-栈和堆内存的区别"><a href="#3-栈和堆内存的区别" class="headerlink" title="3. 栈和堆内存的区别"></a>3. 栈和堆内存的区别</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机组成原理&quot;&gt;&lt;a href=&quot;#计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理&quot;&gt;&lt;/a&gt;计算机组成原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;存储器(内存):&lt;blockquote&gt;
&lt;p&gt;用于存储，实现记忆功能的部件用来存放计算
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.mymgt360124.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://www.mymgt360124.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://www.mymgt360124.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://www.mymgt360124.cn/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
