{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Linux操作系统基础知识","text":"计算机操作系统","link":"/2017/10/05/Linux操作系统的基础知识/"},{"title":"Js面向对象的类型检测","text":"数据类型检测// 接收 任意数量的参数并将其转换为数组的函数 function makeAarry () { // 临时的数组容器 var arr = []; for (var i =0;i&lt; arguments.length;i++) { arr.push(arguments[i]); } return arr; } // 用这一特性可以显示错误信息和默认信息 function displayerror (msg) { if (typeof msg == 'undefined') { msg = &quot;An error occurred&quot;; } alert(msg); } // js数据类型检测 function istypeof (a) { if(typeof a === 'number') { return a+ &quot;is number&quot;; } if ( typeof a === &quot;string&quot;) { return a + &quot;is string&quot; } if ( typeof a === &quot;boolean&quot;) { return a+ &quot;is boolean&quot; } if( typeof a === &quot;function&quot;) { return a + &quot;is function&quot;; } if( a.constructor === Array) { return a + &quot;is Array&quot;; } if (a.constructor === Object) { return a + &quot;is Object&quot;; } } var arr = [], obj = {}; // 因为 typeof arr === &quot;object&quot;; typeof obj === &quot;object&quot;; // 所以用constructor 来检测 属性标签和属性检测// 属性检测Object.definProperty()自定义的方法 Object.defineProperty(car, &quot;price&quot;,{enumerable: false,value :1000 }); 为car 对象设置price 属性，car.price = 1000; // 第一个参数是要添加属性的对象 // 第二个参数设计要添加的属性 // 第三个参数是一个对象(设置一些标签) // enumerable: false; 表示不可枚举，即不能沿原型链向上被 for in 循环到 // value :1000 , 即price 属性的值为1000; 一如果用的字面量和new 创建的对象属性，默认他的enumerable 和 writable 和 configurable 都是为true 的，既可以写，可以删除，可以配置；二如果用Object.defineProperty();不做声明的话，默认创建的对象额属性他的：enumerable和writable和configurable 标签都是为false; configurable: true; 则delete 可以删除的;#geter和seter方法 function Dog () {} Object.defineProperty(Dog.prototype,name',{ get : function () {return &quot;大黄&quot;} }) var dog = Dog(); dog.name;//大黄 也可以这样编写 function Dog () {} Dog.prototype = { name : function () { return &quot;大黄&quot;; } } var dog = new Dog(); dog.name(); //大黄 属性标签value , writable ,enumerable, configurable ; Object.getOwnPropertyDescriptor()获取对象属性标签的状态 Object.getOwnPropertyDescriptor({name: &quot;MGT360124&quot;}, 'name'); //Object{value: true, writable: true,enumable: true,configurable: true} writable:true则属性的值表示可修改enumerable:true表示属性的值可遍历，用for in 遍历则会遍历对象原型的值，可以用Obj.hasOwnProperty(key)过滤;configurable ：true表示属性的值可删除 Object.defineProperties()为对象添加定义多个属性和属性标签var person = {} Object.defineProperties(person,{ name:{value:&quot;MGT360124&quot;,writable: false}, age: {value:18,enumerable: false }, city:{value: &quot;beijing&quot;,enumerable: false}, getLuck: {get : function () { return Math.random(); }}, setCity: {set : function (city) { this.city = city + &quot;--中国&quot;;} } }); person.city; person.setCity = &quot;南昌&quot;; person.city; //南昌--中国 用for in 遍历则会遍历对象原型的值，可以用Obj.hasOwnProperty(key)过滤;阻止for in循环沿原型链向上查找function Dog() { name = '大黄'; } Dog.prototype = { color : &quot;yellow&quot;, getColor : function () { return this.name; } } var dog = new Dog(); dog.name = &quot;二哈&quot; for(var key in dog){ if(dog.hasOwnProperty(key) ) { console.log(dog[key]); // &quot;二哈&quot; } }","link":"/2017/10/08/js面向对象的类型检测/"},{"title":"Vue2利用v-Model实现自定义组件props双向绑定的优美方案","text":"父组件&lt;template&gt; &lt;div class=&quot;keyboard&quot;&gt; &lt;aui-digit-keyboard :label='label' :readonly=&quot;readonly&quot; :disabled=&quot;disabled&quot; :autofocus=&quot;autofocus&quot; :placeholder=&quot;placeholder&quot; :type=&quot;type&quot; :name=&quot;name&quot; :format=&quot;format&quot; :keyboard='keyboard' :maxlength=&quot;maxlength&quot; v-model=&quot;amount&quot;&gt; &lt;/aui-digit-keyboard&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { amount:'', label: &quot;单价&quot;, autofocus: false, disabled:false, maxlength:6, placeholder:&quot;0.00&quot;, readonly:false, type: &quot;tel&quot;, name:&quot;&quot;, format:&quot;&quot;, keyboard:{} } }, watch:{ amount(){ console.log(&quot;this.amount&quot;,this.amount) } }, methods: { } } &lt;/script&gt; 关键是 v-model= ‘amount’和 watch:{amount(){ …}} 子组件&lt;template&gt; &lt;div class=&quot;key-container&quot;&gt; &lt;div class=&quot;input&quot;&gt; &lt;label&gt;{{label}}&lt;/label&gt; &lt;NumericInput :label='label' :readonly=&quot;readonly&quot; :disabled=&quot;disabled&quot; :autofocus=&quot;autofocus&quot; :placeholder=&quot;placeholder&quot; :type=&quot;type&quot; :name=&quot;name&quot; :format=&quot;format&quot; :keyboard='keyboard' :maxlength=&quot;maxlength&quot; v-model=&quot;amount&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { NumericInput } from &quot;numeric-keyboard&quot;; export default { name: &quot;aui-digit-keyboard&quot;, components: { NumericInput, }, data() { return { }; }, computed:{ amount:{ get: function() { return this.value; }, set: function(val) { this.$emit(&quot;input&quot;,val) } } }, methods: { }, props: { label:{ type: String, default: '金额' }, type: { type: String, default: &quot;number&quot; }, autofocus: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, maxlength: { type: Number }, name: { type: String }, placeholder: { type: String }, readonly: { type: Boolean, default: false }, value: { type: [String, Number], default:'' }, format: { type: [String, Function] }, keyboard: { type: Object } } }; &lt;/script&gt; 子组件是在props属性中定义一个value属性 &lt;NumericInput v-model='amount'/&gt; props:{ //接收一个由父组件传递过来的值 value:{ type:String, default:&quot;&quot; } }, computed:{ amount:{ //动态计算amount的值 get:function(){ //将props中的value赋值给 amount return this.value }, set: function(val){ //通过$emit触发父组件,必须用input事件 this.$emit(&quot;input&quot;,val) } } } 在计算属性computed:{}对象中属性不能是data中的也不能是props中的属性","link":"/2017/10/22/vue2利用v-model实现组件props双向绑定的优美方案/"},{"title":"Webpack概念","text":"概念: 本质上，webpack是一个现代JavaScript应用程序的静态模块打包器，当webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle四个核心的概念： 入口(entry) 输出(output) (loader) 插件(plugins) 入口entry入口起点 entry point 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，进入入口起点后，webpack会找出那些模块和库是入口起点(直接和间接)依赖的.每个依赖项随即被处理，最后输出到称之为bundles的文件中可以通过wepack配置中配置entry属性，来指定一个入口起点(或者多个入口起点)。这是一个entry配置的最简单的例子：webpack.config.js module.exports = { entry: './path/to/my/entry/file.js' }; 出口outputoutput属性告诉webpack在哪里输出它所创建的bundles,以及如何命名这些文件。你可以通过在配置中指定一个output字段，来配置这些处理过程：webpack.config.js const path = require(&quot;path&quot;); module.exports = { entry: './path/to/entry/file.js', output: { path: path.resolve(__dirname, &quot;dist&quot;), filename: 'my-first-webpack.bundle.js' } }; 上面的例子，是通过output.filename 和 output.path属性，来告诉webpack bundle的名称，以及我们想要生成(emit)到哪里。 loaderloader让webpack能够去处理那些非JavaScript文件(webpack 自身只理解JavaScript)，loader可以将所有类型文件转换为webpack能够处理的有效模块，然后你就可以利用webpack的打包能力，对他们进行处理。本质上，webpack loader将所有类型文件，转换为应用程序的依赖图(和最终的bundle)可以直接引用的模块。loader能够import导入任何类型的模块(例如.css文件)，这是webpack特有的功能，其他打包程序或任务执行器的可能并不支持，我们认为这种语言扩展是有必要的，因为这可以是开发人员创建出更准确的依赖关系图。在更高层面上，在webpack的配置中loader有两个目标： test属性，用于标识出应该被对应的loader进行转换的某个或某些文件 use属性，表示进行转换时，应该使用哪个loader。webpack.config.jsconst path = require(&quot;path&quot;); const config = { entry: &quot;./path/to/my/entry/file.js&quot;, output: { path: path.resolve(__dirname,&quot;dist&quot;), filename: 'my-first-webpack.bundle.js' }, module: { rules :[ {test: /\\.txt$/, use: 'raw-loader'} ] } } 以上配置中，对一个单独的module对象定义了rules属性，里面包含两个属性：test和use。这告诉webpack编译器compiler一下信息：‘嘿，webpack 编译器，当你碰到在require()/import语句中被解析为.txt的路径时,在你对它打包之前，先使用raw-loader转换一下’ 注意的是，在webpack配置中定义loader时，要定义在module.rules中，而不是rules. 然而，在定义错误时，webpack会给出严重的警告。为了使你受益于此，如果没有按照正确的方式去做，webpack会给出严重的警告。插件loader被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量，插件接口功能极其强大，可以用来处理各种各样的任务。想要使用一个插件，你只需要require()它，然后把它添加到plugins数组中，多数插件可以通过选项option自定义，你也可以在配置文件中应为不同目的而多次使用同一个插件，这时需要通过使用new 操作符来创建它的一个实例webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');//通过npm 安装 const webpack = require(&quot;webpack&quot;); //用于访问内置插件 const path = require(&quot;path&quot;); const config = { entry: './path/to/entry/file.js', output: { path: path.resolve(__dirname,'dist'), filename: 'my-first-webpack.bundle.js' }, module: { rules :[ {test: /\\.txt$/,use: 'raw-loader'} ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: './src/index.html'}) ] }; module.export = config; 入口起点 entry points在webpack配置中有多种方式定义 entry 属性 单个入口语法 用法:entry: string| Arraywebpack.config.js const config = { entry: './path/to/my/entry/file.js' }; module.exports = config; entry 属性的单个入口语法，是下面的简写 const config = { entry: { main: './path/to/my/entry/file.js' } }; 向entry 属性传入[文件路径file path数组]将创建多个主入口。当你想要多个依赖文件一起注入，并且将他们的依赖导向到一个chunk时，传入数组的范式就很有用 对象语法 用法: entry:{[entryChunkName: string]: string| Array}webpack.config.js const config = { entry: { app: './src/app.js', vendors: './src/vendors.js' } }; 对象语法会比较繁琐，然而这时应用程序中定义入口的最可扩展的方式 常见场景分离应用程序app 和第三方库(vendor) 入口webpack.config.js const config = { entry: { app: './src/app.js', vendors: './src/vendors.js' } } 从表面上看，这告诉我们webpack 从app.js 和vendors.js开始创建依赖图 ，这些依赖图是彼此完全分离，相互独立的(每个bundle中都有一个webpack引导bootstrap), 这种方法比较常见，只有一个入口起点(不包括vendor)的单页应用程序(single page application)中。 多页应用程序webpack.config.js const config = { entry: { pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' } } 我们告诉webpack需要3个独立分离的依赖图 输出 output配置output 选项可以控制webpack如何向硬盘写入编译文件，注意，即使可以存在多个入口起点，但只指定一个输出配置。 用法 usage在webpack中配置output属性的最低要求是，将它的值设置为一个对象，包括两点： filename 用于输出文件的文件名。 目标输出目录path的绝对路径。webpack.config.js = { output: { filename: 'bundle.js', path: './home/proj/public/assets' } }; module.exports = config; 此配置将一个单独的bundle.js文件输出到/home/proj/public/assets目录中。 多个入口起点如果配置创建了多个单独的chunk,则应该使用占位符来确保每个文件具有唯一的名称 { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name].js', path: __dirname + '/dist' } } // 写入到硬盘中: ./dist/app.js, ./dist/search.js 高级进阶config.js output :{ path: './home/proj/cdn/assets/[hash]', publicPath: 'http://cdn,example.com/assets/[hash]/' } loaderloader用于对模块的源码进行转换，loader可以使你在import或’加载’模块时预处理文件，因此loader类似于其他构件工具中 ‘任务task’ 并提供了处理前端构建步骤的强大方法，loader可以将文件从不同的语言(例如TypeScript)转换JavaScript,或者内联图像转换为data URL。loader甚至允许你直接在JavaScript模块中 import css文件。 示例使用loader告诉webpack加载css文件，或者TypeScript转换为JavaScript,为此首先安装对应的loader: npm install --save-dev css-loader npm install --save-dev ts-loader 然后指示webpack对每个.css使用css-loader,以及对所有.ts文件使用ts-loader：webpack.config.js module.exports = { module: { rules:[ {test:/\\.css$/, use: 'css-loader'}, {test:/\\.ts$/,use: 'ts-loader'} ] } } 使用loader在应用程序中，有三种方式使用loader： 配置(推荐)，在webpack.config.js文件中指定laoder 内联： 在每个import语句中显式指定loader cli 在shell命令中指定他们 配置[configuration]module.rules 允许你在webpack配置中指定多个loader，这是展示loader的一种简明方式，并且有助于使代码变得简洁，同时让你对各个loader有个全局概览: module :{ rules:[ {test:/\\.css$/, use: [ {loader: 'style-loader'}, { loader: 'css-loader', options: { modules : true } } ] } ] } 内联可以在 import 语句或任何等效于import的方式中指定loader。使用！将资源中的loader分开。分开的每个部分都相对于当前目录解析。 import Styles from 'style-loader!css-loader?modules!./styles.css'; cli 通过处理使用loaderwebpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 这会对.jade文件使用jade-laoder，对.css文件使用style-loader和css-loader loader特性 loader支持链式传递，能够对资源使用流水线pipeline，一组链式的loader将按照相反的顺序执行，loader链式中的第一个loader返回值给下一个loader。在最后一个loader, 返回webpack所预期的JavaScript loader可以是同步的，也可以是一步的 loader 运行在node.js 中，并且能够执行任何可能的操作 loader 也能够使用options 对象进行配置 除了使用package.json常见的main属性，还可以将普通的npm 模块导出为loader, 做法是在 package.json 里定义一个loader字段解析loaderloader遵循标准的模块解析，多数情况下，loader将从模块路径(通常将模块路径认为是npm install, node_modules)解析。 插件Plugins插件是webpack的支柱功能，webpack自身也是构建于，在webpack配置中用到的相同的插件系统之上。插件目的在于解决loader无法实现的其他事。 剖析webpack插件是一个具有apply属性的JavaScript对象。apply属性会被webpack compiler调用，并且compiler对象可在整个编译生命周期访问。ConsoleLogOnBuildWebpackPlugin.js function ConsoleLogOnBuildWebpackPlugin () { } ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) { compiler.plugin('run',function(compiler,callback){ console.log(&quot;webpack 构建过程开始！！！&quot;); callback(); }); }; 用法 由于插件可以携带参数、选项。在webpack配置中，向plugins属性传入new 实例。配置webpack.config.js const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); //通过npm安装 const webpack = require(&quot;webpack&quot;); //访问内置的插件 const path = require(&quot;path&quot;); const config = { entry: &quot;./path/to/my/entry/file.js&quot;, output: { filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname,&quot;dist&quot;) }, module:{ loaders: [ { test: /\\.(js|jsx)$/, use: 'babel-loader' } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: './src/index.html'}) ] }; module.exports = config; node api即使使用node api ,用户也应该在配置中传入plugins属性，compiler.apply并不是推荐的使用方式。some-node-script.js const webpack = require(&quot;webpack&quot;); const configuration = require(&quot;./webpack.config.js&quot;); let compiler = webpack(configuration); compiler.apply(new webpack.ProgressPlugin()); compiler.run(function (err,stats) { //... }); 配置configuration很少有webpack配置看起来很完全相同，这是因为webpack的配置文件，是导出一个对象的JavaScript文件，此对象由webpack根据对象定义的属性进行解析。因为webpack配置是标准的node.js commonJS模块，你可以做到以下事情： 通过require(…) 导入其他文件 通过require(…) 使用npm的工具函数 使用JavaScript控制流表达式，例如 ?:操作符 对常用值使用常量或变量 编写并执行函数来生成部分配置 但是应该避免以下做法: 在使用webpack命令行接口cli(应该编写自己的命令行cli,或者使用 –env)时，访问命令行接口cli参数 导出不确定的值(调用webpack两次应该产生同样的输出文件) 编写很长的配置(应该讲配置拆分为多个文件) 最简单的配置webpack.config.js var path = require('path'); module.exports = { entry: './foo.js', output: { path: path.resolve(_dirname,'dist'), filename: 'foo.bundle.js' } }; 模块Modules在模块化编程中，开发者将程序分解成离散功能块，并称之为模块。每个模块具有比完整程序更小的接触面，是的校验，调试，测试轻而易举。精心编写的模块提供了可靠的抽象和封装界限，是的应用程序中每个模块都具有条理清晰的设计和明确的目的。 什么是webpack模块对比node.js模块，webpack模块能够以各种方式表达他们的依赖关系， ES5 import语句 CommonJS require()语句 AMD define和require()语句 css/sass/less文件中的@import语句 样式url() 或者HTML中的图片链接image url 支持的模块类型webpack 通过loader可以支持各种语言和预处理器编写模块，loader描述了webpack如何处理非JavaScript模块，并且在bundle中引入这些依赖，webpack社区已经为各种流行语言和语言吹器构建了loader coffeeScript TypeScript ESNext sass less stylus模块解析 module resolutionresolver 是一个库 ，用于帮助找到模块的绝对路径，一个模块可以作为另一个模块的依赖模块，然后被后者引用。import foo from 'path/to/module' // 或者 require('path/to/module') 所依赖的模块可以使来自应用程序代码或者第三方的库,resolver帮助webpack找到bundle中需要引入的模块代码，这些代码在包含在每个require/import语句中，当打包模块时，webpack使用enhanced-resolve来解析文件的路径webpack 中解析规则使用enhanced-resolve，webpack能够解析三种文件路径： 绝对路径，相对路径，模块路径 绝对路径 import '/home/me/file'; import 'C:\\\\Users\\\\me\\\\file'; 由于我们已经有了文件的绝对路径，因此不需要在进一步解析 相对路径 import '../src/file1'; import './file2' 在这种情况下，使用import或者require的资源文件resource file所在的目录被认为是上下文目录context directory，在import /require中给定的相对路径，会添加次上下文路径context path,以产生模块的绝对路径. 依赖图 dependency graph任何时候，一个文件依赖于另一个文件，webpack就把此视为文件之间的依赖关系，这使得webpack可以接受非代码资源例如图像或者web字体，并且可以把他们作为依赖提供给你的应用程序。webpack 从命令行或者配置文件中定义的一个模块列表开始，处理你的应用程序，从这些入口七点开始，webpack递归的构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的bundle，通常只有一个。 构建目标 Targets要设置target属性，只需要在你的webpack配置中设置target的值webpack.config.js module.exports = { target: 'node' }; 更多说明，请参考webpack官网","link":"/2017/10/10/webpack/"},{"title":"用Js获取网页元素的位置","text":"网页的大小和浏览器窗口的大小一张网页的全部面积，就是它的大小，通常情况下，网页的大小由内容和css样式表决定。浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport(视口)。很显然，如果网页的内容能够在浏览器窗口中全部显示（也就是不出现滚动条），那么网页的大小和浏览器窗口的大小是相等的。如果不能全部显示，则滚动浏览器窗口，可以显示出网页的各个部分。 获取网页的大小网页上的每个元素，都有clientHeight和clientWidth属性，这两个属性指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。因此，document元素的clientHeight和clientWidth属性，就代表了网页的大小 function getViewport(){ if(document.compatMode == 'BackCompat'){ return { wdith: document.body.clientWidth, height: document.body.clientHeight } }else{ return { width: document.documentElement.clientWdith, height: document.documentElement.clientHeight } } } getViewport函数就可以返回浏览器窗口的高度和宽度，使用的时候，有三个地方需要注意：1, 这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。2, 大多数情况下，都是document.documentElement.clientWidth返回正确的值，但是在IE6中document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。3, clientWidth和clientHeight都是只读属性。不能对他们赋值 获取网页大小的另一种方法网页上的每个元素还有scrollHeight和scrollWidth属性，，指包含滚动条在内的该元素的视觉面积，那么document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。 function getPagearea (){ if (document.compatMode == 'BackCompat'){ return { width: document.body.scrollWidth, height: document.body.scrollHeight } }else { return { width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight } } } 这个函数有个问题，如果网页内容能够在浏览器中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth是相等的。 但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对getPagearea()函数进行改写。 function getPagearea () { if(document.compatMode == 'BackCompat'){ return { width: Math.max(document.body.scrollWidth,document.body.clientWidth), height: Math.max(document.body.scrollHeight,document.body.clientHeight) } }else{ return { width : Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientWidth) } } } 获取网页元素的绝对位置网页元素的绝对位置，指该元素的左上角相对于整个网页左上角的坐标，这个坐标要通过计算才能得到。首先，每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器(offsetParent对象)左上角的距离，所以只需将这个值进行累加，就可以得到该元素的绝对坐标。下面两个函数可用来获取绝对位置的横纵坐标 function getElementLeft (element) { var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current ! == null) { actualLeft + = current.offsetLeft; current = current.offsetParent; } return actualLeft; } function getElementTop (element) { var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null ) { actualTop += current.offsetTop; current = current.offsetParent; } return actualTop; } 由于在表格和iframe中，offsetParent对象未必等于父容器，所以上面的函数对于表格和iframe中的元素不适用。 获取网页元素的相对位置 网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标 有了绝对位置以后，获取相对位置就很容易了。只要将绝对坐标减去页面的滚动条滚动的距离就可以了，滚动条滚动的垂直距离，是document对象的scrollTop属性，滚动条滚动的水平距离是document对象的scrollLeft属性。 function getElementViewLeft (element) { var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current ! == null) { actualLeft += current.offsetLeft; current = current.offsetParent; } if (document.compatMode == 'BackCompat') { var elementScrollLeft = document.body.scrollLeft; }else { var elementScrollLeft = document.documentElement.scrollLeft; } return actualLeft - elementScrollLeft; } function getElementViewTop (element) { var actualTop = element.offsetTop var current = element.offsetParent while (current ! == null) { actualTop += current.offsetTop; current = current.offsetParent } if (document.compatMode == 'BackCompat') { var elementScrollTop = document.body.scrollTop; }else { var elementScrollTop = document.documentElement.scrollTop } return actualTop - elementScrollTop; } scrollTop和scrollLeft属性是可以赋值的，并且会立即自动滚动网页到相应的位置。因此可以利用他们改变网页元素的相对位置，另外，element.scrollIntoView()方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。 获取元素位置的快速方法除了上面的函数以外，还有一种快速方法，可以立刻获得网页元素的位置那就是使用getBoundingClientRect()方法，它返回一个对象，其中包含了left ,right, top, bottom 四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口viewport左上角的距离。所以，网页元素的相对位置就是 var X = this.getBoundingClientRect().left; var Y = this.getBoundingClientRect().top; 再加上滚动距离，就可以得到绝对位置 var X = this.getBoundingClientRect().left + document.documentElement.scrollLeft; var Y = this.getBoundingClientRect().top + document.documentElement.scrollTop; 1, clientWidth/clientHeight2, scrollWidth/scrollHeight 和 scrollLeft/scrollTop3, offsetWidth/offsetHeight 和 offsetLeft/offsetTop4, this.getBoundingClientRect()对象的left,right,top,bottom四个属性，分别对应该元素的左上角和右下角相对于浏览器视口左上角的距离。目前，IE、Firefox 3.0+、Opera 9.5+都支持该方法，而Firefox 2.x、Safari、Chrome、Konqueror不支持。参考链接","link":"/2017/10/06/用js获取网页元素的位置/"},{"title":"计算机网络基础知识","text":"计算机网络 1. 客户端和服务端的问候礼用自己的话去概括一个理论或者概念，然后试着将自己的话讲述给别人听，看别人是否理解这种概念。一是概括理论，二是讲理论或者方法的应用场景，三是讲这个理论的优点或者缺点。 2. mac地址是48位二进制数表示的，通常用12个十六进制数表示。以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 mac地址是将所有的数据包发送给统一子网络下的所有计算机，这个过程首先需要ip地址来确定是哪一个子网络。","link":"/2017/10/05/计算机网络基础知识/"},{"title":"计算机组成基础知识","text":"计算机组成原理 存储器(内存): 用于存储，实现记忆功能的部件用来存放计算程序及参与运算的各种数据 运算器(cpu): 负责数据的算术运算和逻辑运算即数据的加工处理 控制器: 负责对程序规定的控制信息进行分析,控制并协调输入,输出操作或内存访问 输入设备: 实现计算程序和原始数据的输入 输出设备: 实现计算结果输出 计算机体系结构图 内存图 存储器定义:计算机存储是存放数据和程序的设备 分类: 主存储器: 也称内存,存储直接与CPU交换信息,由半导体存储器组成 辅助存储器: 也称外存,存放当前不立即使用的信息,它与主存储器批量交换信息,由磁带机,磁带盘及光盘组成 1. 异步I/O流和同步I/O流2. 进程和线程3. 栈和堆内存的区别","link":"/2017/10/05/计算机组成原理/"}],"tags":[{"name":"计算机","slug":"计算机","link":"/tags/计算机/"},{"name":"linux操作系统","slug":"linux操作系统","link":"/tags/linux操作系统/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"css3","slug":"css3","link":"/tags/css3/"},{"name":"网络","slug":"网络","link":"/tags/网络/"},{"name":"组成原理","slug":"组成原理","link":"/tags/组成原理/"}],"categories":[{"name":"计算机","slug":"计算机","link":"/categories/计算机/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"linux操作系统","slug":"计算机/linux操作系统","link":"/categories/计算机/linux操作系统/"},{"name":"网络","slug":"计算机/网络","link":"/categories/计算机/网络/"},{"name":"组成原理","slug":"计算机/组成原理","link":"/categories/计算机/组成原理/"},{"name":"vue","slug":"javascript/vue","link":"/categories/javascript/vue/"},{"name":"webpack","slug":"javascript/webpack","link":"/categories/javascript/webpack/"},{"name":"vue.js","slug":"javascript/webpack/vue-js","link":"/categories/javascript/webpack/vue-js/"}]}